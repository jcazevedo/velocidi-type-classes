#+TITLE: Type classes in Scala
#+SUBTITLE: Velocidi Tech Talks

#+AUTHOR: Joao Azevedo

#+DATE: November 16, 2018

* Outline

1. Polymorphism
2. Type classes
3. Running example
4. Derivation of type classes
5. Shapeless
6. Generic derivation of type classes
7. Configuring derivation
8. Other resources

* Polymorphism

#+BEGIN_QUOTE
In computer science, a type class is a type system construct that supports ad hoc polymorphism. This
is achieved by adding constraints to type variables in parametrically polymorphic types.
                                                                                        -- [[https://en.wikipedia.org/wiki/Type_class][Wikipedia]]
#+END_QUOTE

* Parametric polymorphism

Parametric polymorphism allows a function or data type to handle values uniformly without depending
on their type.

#+BEGIN_SRC scala
def length[A](xs: List[A]) = xs match {
  case Nil => 0
  case _ :: t => 1 + length(t)
}

val l1: List[Int]    = List(1, 2, 3)
val l2: List[String] = List("a", "b", "c")
val l3: List[Double] = List(1.0, 2.0, 3.0)

length(l1) //// => 3
length(l2) //// => 3
length(l3) //// => 3
#+END_SRC

* Parametric polymorphism

Parametric polymorphism allows a function or data type can handle values uniformly without depending
on their type.

#+BEGIN_SRC scala
sealed trait List[+A]
case object Nil extends List[Nothing]
case class Cons[A](head: A, tail: List[A]) extends List[A]

val l1: List[Int]    = Cons(1, Cons(2, Cons(3, Nil)))
val l2: List[String] = Cons("a", Cons("b", Cons("c", Nil)))
val l3: List[Double] = Cons(1.0, Cons(2.0, Cons(3.0, Nil)))
#+END_SRC

* Subtype polymorphism

Subtyping allows a function to take an object of a certain type, but also work correctly for
subtypes.

#+BEGIN_SRC scala
trait Animal {
  def talk: String
}

class Cat extends Animal {
  def talk = "Meow!"
}

class Dog extends Animal {
  def talk = "Woof!"
}

def hear(a: Animal): String = a.talk

hear(new Cat) //// => "Meow!"
hear(new Dog) //// => "Woof!"
#+END_SRC

* Ad hoc polymorphism

Ad hoc polymorphism is a kind of polymorphism in which polymorphic functions can be applied to
arguments of different types.

#+BEGIN_SRC scala
def add(x: Int, y: Int) = x + y
def add(x: String, y: String) = x + y

add(1, 2) //// => 3
add("a", "b") //// => "ab"
#+END_SRC

* Ad hoc polymorphism

Ad hoc polymorphism is a kind of polymorphism in which polymorphic functions can be applied to
arguments of different types.

#+BEGIN_SRC scala
def hear(c: Cat) = "Meow!"
def hear(c: Dog) = "Woof!"

hear(new Cat) //// => "Meow!"
hear(new Dog) //// => "Woof!"
#+END_SRC

* Type classes

Type classes were first introduced in Haskell and provide an additional way to support ad hoc
polymorphism. In Haskell, if a type is part of a type class, then it supports and implements the
behavior the type class describes.

There is no special syntax in Scala to express a type class, but we can achieve the same
functionality with constructs of the language.

#+BEGIN_SRC scala
trait Talker[A] {
  def talk(x: A): String
}

object Talker {
  val dogTalker: Talker[Dog] = new Talker[Dog] {
    def talk(x: Dog) = "Woof!"
  }

  val catTalker: Talker[Cat] = new Talker[Cat] {
    def talk(x: Cat) = "Meow!"
  }
}

Talker.dogTalker.talk(new Dog) //// => "Woof!"
Talker.catTalker.talk(new Cat) //// => "Meow!"
#+END_SRC

* Type classes

We can avoid calling the Talker's explicitly by making the Talker implicit in the hear method:

#+BEGIN_SRC scala
trait Talker[A] {
  def talk(x: A): String
}

object Talker {
  implicit val dogTalker: Talker[Dog] = new Talker[Dog] {
    def talk(x: Dog) = "Woof!"
  }

  implicit val catTalker: Talker[Cat] = new Talker[Cat] {
    def talk(x: Cat) = "Meow!"
  }
}

def hear[A](x: A)(implicit talker: Talker[A]) = talker.talk(x)

hear(new Dog) //// => "Woof!"
hear(new Cat) //// => "Meow!"
#+END_SRC

* Type classes

We can improve this by adding a way to call talk on instances that have a Talker type class:

#+BEGIN_SRC scala
implicit class TalkerOps[A: Talker](x: A) {
  def talk = implicitly[Talker[A]].talk(x)
}

(new Dog).talk //// => "Woof!"
(new Cat).talk //// => "Meow!"
#+END_SRC

* Running example

We're going to use Typesafe Config as a running example throughout this presentation, attempting to
create a type class based solution to read and write ConfigValues. The Typesafe Config classes can
be summarized in:

#+BEGIN_SRC java
public interface ConfigValue
abstract class ConfigNumber extends ConfigValue
final class ConfigDouble extends ConfigNumber
final class ConfigInt extends ConfigNumber
final class ConfigLong extends ConfigNumber
final class ConfigBoolean extends ConfigValue
abstract class ConfigString extends ConfigValue
public interface ConfigObject extends ConfigValue, Map<String, ConfigValue>
public interface ConfigList extends ConfigValue, List<ConfigValue>
#+END_SRC
