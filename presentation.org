#+TITLE: Type classes in Scala
#+SUBTITLE: Velocidi Tech Talks

#+AUTHOR: Joao Azevedo

#+DATE: November 16, 2018

* Outline

1. Polymorphism
2. Type classes
3. Running example
4. Derivation of type classes
5. Shapeless
6. Generic derivation of type classes
7. Configuring derivation
8. Other resources

* Polymorphism

#+BEGIN_QUOTE
In computer science, a type class is a type system construct that supports ad hoc polymorphism. This
is achieved by adding constraints to type variables in parametrically polymorphic types.
                                                                                        -- [[https://en.wikipedia.org/wiki/Type_class][Wikipedia]]
#+END_QUOTE

* Parametric polymorphism

Parametric polymorphism allows a function or data type to handle values uniformly without depending
on their type.

#+BEGIN_SRC scala
def length[A](xs: List[A]) = xs match {
  case Nil => 0
  case _ :: t => 1 + length(t)
}

val l1: List[Int]    = List(1, 2, 3)
val l2: List[String] = List("a", "b", "c")
val l3: List[Double] = List(1.0, 2.0, 3.0)

length(l1) //// => 3
length(l2) //// => 3
length(l3) //// => 3
#+END_SRC

* Parametric polymorphism

Parametric polymorphism allows a function or data type can handle values uniformly without depending
on their type.

#+BEGIN_SRC scala
sealed trait List[+A]
case object Nil extends List[Nothing]
case class Cons[A](head: A, tail: List[A]) extends List[A]

val l1: List[Int]    = Cons(1, Cons(2, Cons(3, Nil)))
val l2: List[String] = Cons("a", Cons("b", Cons("c", Nil)))
val l3: List[Double] = Cons(1.0, Cons(2.0, Cons(3.0, Nil)))
#+END_SRC

* Subtype polymorphism

Subtyping allows a function to take an object of a certain type, but also work correctly for
subtypes.

#+BEGIN_SRC scala
trait Animal {
  def talk: String
}

class Cat extends Animal {
  def talk = "Meow!"
}

class Dog extends Animal {
  def talk = "Woof!"
}

def hear(a: Animal): String = a.talk

hear(new Cat) //// => "Meow!"
hear(new Dog) //// => "Woof!"
#+END_SRC

* Ad hoc polymorphism

Ad hoc polymorphism is a kind of polymorphism in which polymorphic functions can be applied to
arguments of different types.

#+BEGIN_SRC scala
def add(x: Int, y: Int) = x + y
def add(x: String, y: String) = x + y

add(1, 2) //// => 3
add("a", "b") //// => "ab"
#+END_SRC

* Ad hoc polymorphism

Ad hoc polymorphism is a kind of polymorphism in which polymorphic functions can be applied to
arguments of different types.

#+BEGIN_SRC scala
def hear(c: Cat) = "Meow!"
def hear(c: Dog) = "Woof!"

hear(new Cat) //// => "Meow!"
hear(new Dog) //// => "Woof!"
#+END_SRC

* Type classes

Type classes were first introduced in Haskell and provide an additional way to support ad hoc
polymorphism. In Haskell, if a type is part of a type class, then it supports and implements the
behavior the type class describes.

There is no special syntax in Scala to express a type class, but we can achieve the same
functionality with constructs of the language.

#+BEGIN_SRC scala
trait Talker[A] {
  def talk(x: A): String
}

object Talker {
  val dogTalker: Talker[Dog] = new Talker[Dog] {
    def talk(x: Dog) = "Woof!"
  }

  val catTalker: Talker[Cat] = new Talker[Cat] {
    def talk(x: Cat) = "Meow!"
  }
}

Talker.dogTalker.talk(new Dog) //// => "Woof!"
Talker.catTalker.talk(new Cat) //// => "Meow!"
#+END_SRC

* Type classes

We can avoid calling the Talker's explicitly by making the Talker implicit in the hear method:

#+BEGIN_SRC scala
trait Talker[A] {
  def talk(x: A): String
}

object Talker {
  implicit val dogTalker: Talker[Dog] = new Talker[Dog] {
    def talk(x: Dog) = "Woof!"
  }

  implicit val catTalker: Talker[Cat] = new Talker[Cat] {
    def talk(x: Cat) = "Meow!"
  }
}

def hear[A](x: A)(implicit talker: Talker[A]) = talker.talk(x)

hear(new Dog) //// => "Woof!"
hear(new Cat) //// => "Meow!"
#+END_SRC

* Type classes

We can improve this by adding a way to call talk on instances that have a Talker type class:

#+BEGIN_SRC scala
implicit class TalkerOps[A: Talker](x: A) {
  def talk = implicitly[Talker[A]].talk(x)
}

(new Dog).talk //// => "Woof!"
(new Cat).talk //// => "Meow!"
#+END_SRC

* Running example

We're going to use Typesafe Config as a running example throughout this presentation, attempting to
create a type class based solution to read and write ConfigValues. The Typesafe Config classes can
be summarized in:

#+BEGIN_SRC java
public interface ConfigValue
abstract class ConfigNumber extends ConfigValue
final class ConfigDouble extends ConfigNumber
final class ConfigInt extends ConfigNumber
final class ConfigLong extends ConfigNumber
final class ConfigBoolean extends ConfigValue
abstract class ConfigString extends ConfigValue
public interface ConfigObject extends ConfigValue, Map<String, ConfigValue>
public interface ConfigList extends ConfigValue, List<ConfigValue>
#+END_SRC

* Running example

#+BEGIN_SRC scala
trait ConfigReader[A] {
  def read(configValue: ConfigValue): A
}

object ConfigReader {
  object Ops {
    implicit class ConfigReaderOps(x: ConfigValue) {
      def as[A: ConfigReader]: A =
        implicitly[ConfigReader[A]].read(x)
    }
  }
}
#+END_SRC

* Running example

#+BEGIN_SRC scala
trait ConfigWriter[A] {
  def write(value: A): ConfigValue
}

object ConfigWriter {
  object Ops {
    implicit class ConfigWriterOps[A: ConfigWriter](x: A) {
      def toConfig: ConfigValue =
        implicitly[ConfigWriter[A]].write(x)
    }
  }
}
#+END_SRC

* Basic readers

#+BEGIN_SRC scala
trait BasicReaders {
  implicit val intReader: ConfigReader[Int] = new ConfigReader[Int] {
    def read(configValue: ConfigValue): Int = configValue.unwrapped.asInstanceOf[Int]
  }

  implicit val longReader: ConfigReader[Long] = new ConfigReader[Long] {
    def read(configValue: ConfigValue): Long = configValue.unwrapped.asInstanceOf[Long]
  }

  implicit val doubleReader: ConfigReader[Double] = new ConfigReader[Double] {
    def read(configValue: ConfigValue): Double = configValue.unwrapped.asInstanceOf[Double]
  }

  implicit val stringReader: ConfigReader[String] = new ConfigReader[String] {
    def read(configValue: ConfigValue): String = configValue.unwrapped.asInstanceOf[String]
  }

  implicit val booleanReader: ConfigReader[Boolean] = new ConfigReader[Boolean] {
    def read(configValue: ConfigValue): Boolean = configValue.unwrapped.asInstanceOf[Boolean]
  }
}

object ConfigReader extends BasicReaders
#+END_SRC

* Basic readers

#+BEGIN_SRC scala
import ConfigReader.Ops._

val conf = ConfigFactory.parseString(
  """|{
     |  a = 1
     |  b = 1099511627776
     |  c = 4.5
     |  d = "str"
     |  e = false
     |}""".stripMargin)

conf.getValue("a").as[Int] //// => 1
conf.getValue("b").as[Long] //// => 1099511627776l
conf.getValue("c").as[Double] //// => 4.5
conf.getValue("d").as[String] //// => "str"
conf.getValue("e").as[Boolean] //// => false
#+END_SRC

* Basic writers

#+BEGIN_SRC scala
trait BasicWriters {
  implicit val intWriter: ConfigWriter[Int] = new ConfigWriter[Int] {
    def write(value: Int): ConfigValue = ConfigValueFactory.fromAnyRef(value)
  }

  implicit val longWriter: ConfigWriter[Long] = new ConfigWriter[Long] {
    def write(value: Long): ConfigValue = ConfigValueFactory.fromAnyRef(value)
  }

  implicit val doubleWriter: ConfigWriter[Double] = new ConfigWriter[Double] {
    def write(value: Double): ConfigValue = ConfigValueFactory.fromAnyRef(value)
  }

  implicit val stringWriter: ConfigWriter[String] = new ConfigWriter[String] {
    def write(value: String): ConfigValue = ConfigValueFactory.fromAnyRef(value)
  }

  implicit val booleanWriter: ConfigWriter[Boolean] = new ConfigWriter[Boolean] {
    def write(value: Boolean): ConfigValue = ConfigValueFactory.fromAnyRef(value)
  }
}

object ConfigWriter extends BasicWriters
#+END_SRC

* Basic writers

#+BEGIN_SRC scala
import ConfigWriter.Ops._

1.toConfig //// => ConfigInt(1)
1099511627776l.toConfig //// => ConfigLong(1099511627776)
4.5.toConfig //// => ConfigDouble(4.5)
"str".toConfig //// => Quoted("str")
false.toConfig //// => ConfigBoolean(false)
#+END_SRC

* Derivation of type classes

Building upon available readers and writers, we can start deriving type classes for collection
types:

#+BEGIN_SRC scala
import scala.collection.JavaConverters._
import scala.collection.generic.CanBuildFrom
import scala.language.higherKinds

trait CollectionReaders {
  implicit def traversableReader[A, F[A] <: TraversableOnce[A]](
    implicit
    reader: ConfigReader[A],
    cbf: CanBuildFrom[F[A], A, F[A]]): ConfigReader[F[A]] = new ConfigReader[F[A]] {
    def read(configValue: ConfigValue): F[A] =
      configValue.asInstanceOf[ConfigList].asScala.foldLeft(cbf()) {
        case (acc, x) => acc += reader.read(x)
      }.result()
  }
}

object ConfigReader extends CollectionReaders
#+END_SRC

* Derivation of type classes

#+BEGIN_SRC scala
val conf = ConfigFactory.parseString(
  """|{
     |  a = 1
     |  b = 1099511627776
     |  c = 4.5
     |  d = "str"
     |  e = false
     |  f = [1, 2, 3]
     |}""".stripMargin)

conf.getValue("f").as[List[Int]] //// => List(1, 2, 3)
conf.getValue("f").as[Set[Int]] //// => Set(1, 2, 3)
#+END_SRC
